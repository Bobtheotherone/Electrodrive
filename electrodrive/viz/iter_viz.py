# electrodrive/viz/iter_viz.py
"""
Iteration visualization helpers for Electrodrive.

Two entrypoints:

- overlay_metrics_on_frames(out_dir, logger):
    Post-hoc overlay for frames generated by electrodrive.cli._render_visualizations.
    Reads:
        OUT_DIR/metrics.json
        OUT_DIR/evidence_log.jsonl
        OUT_DIR/viz/*.png
    Overlays:
        - Last known GMRES iteration + residual (sci)
        - If present: tile_src x tile_tgt (or tile_size) and per-iteration ms
        - If present: GPU memory watermark from metrics.json (gpu_mem_peak_mb)
    Writes:
        - Annotated PNGs as viz_XXXX_overlay.png (or viz_overlay.png)
        - ai_iter.mp4 at 12 fps if imageio_ffmpeg is available (best-effort).

- IterVizRecorder:
    Lightweight per-iteration recorder to emit synthetic frames without
    touching solver math. Designed for in-run use by callers.

Constraints:
    - No new hard dependencies.
    - Use stdlib, matplotlib, and optional imageio/imageio_ffmpeg if present.
    - All I/O must be robust; never raise to caller on failures.
    - Atomic writes via temp file + os.replace.
"""

from __future__ import annotations

import json
import os
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Tuple

from electrodrive.utils.logging import JsonlLogger

# -----------------------------------------------------------------------------
# Optional imports (lazy where possible)
# -----------------------------------------------------------------------------

try:  # Pillow is optional; ai_solve already assumes it when installed
    from PIL import Image, ImageDraw, ImageFont  # type: ignore

    _HAVE_PIL = True
except Exception:  # pragma: no cover
    Image = ImageDraw = ImageFont = None  # type: ignore
    _HAVE_PIL = False


# -----------------------------------------------------------------------------
# Small utilities
# -----------------------------------------------------------------------------

def _safe_float(v: Any) -> Optional[float]:
    try:
        if isinstance(v, (int, float)):
            return float(v)
        if isinstance(v, str):
            return float(v.strip())
    except Exception:
        return None
    return None


def _scientific(v: Optional[float]) -> str:
    if v is None:
        return "nan"
    try:
        return f"{float(v):.3e}"
    except Exception:
        return "nan"


def _atomic_write_bytes(path: Path, data: bytes) -> None:
    """
    Atomic write helper (best-effort).
    """
    try:
        tmp = path.with_suffix(path.suffix + ".tmp")
        with tmp.open("wb") as f:
            f.write(data)
        os.replace(tmp, path)
    except Exception:
        # Best-effort; caller should swallow.
        pass


def _atomic_write_image(img: "Image.Image", path: Path) -> None:  # type: ignore[name-defined]
    """
    Atomic write for Pillow images.
    """
    try:
        tmp = path.with_suffix(path.suffix + ".tmp")
        img.save(tmp)
        os.replace(tmp, path)
    except Exception:
        pass


def _list_frame_paths(viz_dir: Path) -> List[Path]:
    """
    Return PNG frames in deterministic order.

    Prefers viz_*.png; falls back to viz.png if present.
    """
    frames = sorted(viz_dir.glob("viz_*.png"))
    if frames:
        return frames
    single = viz_dir / "viz.png"
    if single.is_file():
        return [single]
    return []


# -----------------------------------------------------------------------------
# Evidence log parsing with offset
# -----------------------------------------------------------------------------

@dataclass
class IterSample:
    iter: int
    resid: float
    tile_src: Optional[int] = None
    tile_tgt: Optional[int] = None
    t_iter_ms: Optional[float] = None


def _parse_iter_event(rec: Dict[str, Any]) -> Optional[IterSample]:
    """
    Extract IterSample from a single JSONL record, if it looks like a GMRES iteration.
    """
    msg = str(rec.get("event", "")).lower()

    # Two event styles we care about:
    # - "GMRES iter." from bem_solve callback (iter/resid + context)
    # - "GMRES progress." from gmres_restart
    if "gmres iter." in msg:
        i = rec.get("iter", rec.get("iters"))
        r = rec.get("resid")
    elif "gmres progress." in msg:
        i = rec.get("iters", rec.get("iter"))
        r = rec.get("resid")
    else:
        return None

    i_f = _safe_float(i)
    r_f = _safe_float(r)
    if i_f is None or r_f is None:
        return None

    # Tile hints: prefer explicit src/tgt if present; otherwise tile_size.
    tile_src = rec.get("tile_src")
    tile_tgt = rec.get("tile_tgt")
    ts = rec.get("tile_size")
    # Normalize tile fields to ints when meaningful.
    ts_i = int(ts) if isinstance(ts, (int, float)) else None
    t_src_i = int(tile_src) if isinstance(tile_src, (int, float)) else None
    t_tgt_i = int(tile_tgt) if isinstance(tile_tgt, (int, float)) else None

    # Iteration timing: accept ms or sec fields if present.
    t_ms = None
    for key in ("t_iter_ms", "t_ms", "ms_per_iter"):
        if key in rec:
            t_ms = _safe_float(rec.get(key))
            break
    if t_ms is None and "t_iter" in rec:
        # assume seconds
        val = _safe_float(rec.get("t_iter"))
        if val is not None:
            t_ms = 1e3 * val

    return IterSample(
        iter=int(i_f),
        resid=float(r_f),
        tile_src=t_src_i or ts_i,
        tile_tgt=t_tgt_i,
        t_iter_ms=t_ms,
    )


def _read_evidence_incremental(
    evidence_path: Path,
    offset_path: Path,
) -> Tuple[List[IterSample], int]:
    """
    Incrementally parse evidence_log.jsonl from a stored byte offset.

    Returns (samples, new_offset).
    All errors are swallowed; on error, behaves as if no samples.
    """
    samples: List[IterSample] = []
    if not evidence_path.is_file():
        return samples, 0

    try:
        start = 0
        if offset_path.is_file():
            try:
                raw = offset_path.read_text(encoding="utf-8").strip()
                if raw:
                    start = int(raw)
            except Exception:
                start = 0

        with evidence_path.open("r", encoding="utf-8") as f:
            if start > 0:
                try:
                    f.seek(start)
                except Exception:
                    # Seek may fail if file shrunk; restart from 0
                    f.seek(0)
            while True:
                pos = f.tell()
                line = f.readline()
                if not line:
                    new_off = pos
                    break
                line = line.strip()
                if not line:
                    continue
                try:
                    rec = json.loads(line)
                except Exception:
                    continue
                if isinstance(rec, dict):
                    sample = _parse_iter_event(rec)
                    if sample is not None:
                        samples.append(sample)

        # In case loop exited via break with new_off
        try:
            new_offset = new_off  # type: ignore[name-defined]
        except NameError:
            # If we never read, keep previous
            new_offset = start

        return samples, int(new_offset)
    except Exception:
        return [], 0


# -----------------------------------------------------------------------------
# Metrics loader
# -----------------------------------------------------------------------------

@dataclass
class MetricsInfo:
    gpu_mem_peak_mb: Optional[float] = None


def _load_metrics_info(metrics_path: Path) -> MetricsInfo:
    if not metrics_path.is_file():
        return MetricsInfo()
    try:
        data = json.loads(metrics_path.read_text(encoding="utf-8"))
    except Exception:
        return MetricsInfo()
    if not isinstance(data, dict):
        return MetricsInfo()
    m = data.get("metrics", data)
    peak = _safe_float(
        m.get("gpu_mem_peak_mb")
        or m.get("gpu_peak_mb")
        or (m.get("vram_telemetry", {}) or {}).get("gpu_mem_peak_mb")
    )
    return MetricsInfo(gpu_mem_peak_mb=peak)


# -----------------------------------------------------------------------------
# Overlay rendering
# -----------------------------------------------------------------------------


def _ensure_pil() -> bool:
    return _HAVE_PIL


def _draw_overlay_on_image(
    base: "Image.Image",  # type: ignore[name-defined]
    text_lines: Iterable[str],
) -> "Image.Image":  # type: ignore[name-defined]
    """
    Draw a small semi-transparent panel in top-left with provided lines.
    """
    im = base.convert("RGBA")
    draw = ImageDraw.Draw(im)

    try:
        font = ImageFont.load_default()
    except Exception:
        font = None  # type: ignore

    # Measure text
    margin = 6
    lines = [str(s) for s in text_lines if str(s).strip()]
    if not lines:
        return im

    max_w = 0
    total_h = 0
    for line in lines:
        try:
            bbox = draw.textbbox((0, 0), line, font=font)
            w = bbox[2] - bbox[0]
            h = bbox[3] - bbox[1]
        except Exception:
            # Fallback approximate values
            w = 8 * len(line)
            h = 10
        max_w = max(max_w, w)
        total_h += h + 2

    box_w = min(im.width, max_w + 2 * margin)
    box_h = min(im.height, total_h + 2 * margin)

    # Draw semi-transparent background
    box = (0, 0, box_w, box_h)
    draw.rectangle(box, fill=(0, 0, 0, 180))

    # Draw text
    y = margin
    for line in lines:
        try:
            draw.text((margin, y), line, fill=(255, 255, 255, 240), font=font)
            bbox = draw.textbbox((0, 0), line, font=font)
            h = bbox[3] - bbox[1]
        except Exception:
            h = 10
        y += h + 2

    return im


def overlay_metrics_on_frames(out_dir: Path, logger: JsonlLogger) -> None:
    """
    Post-hoc overlay metrics onto existing viz frames in OUT_DIR/viz.

    Safe no-op on any failure.

    Policy:
        - Read GMRES samples from evidence_log.jsonl incrementally.
        - For each viz_*.png (and/or viz.png), write *_overlay.png with:
            Iter X  Resid Y
            Tiles: ...
            t_iter: ... ms
            GPU: ... MB
        - If imageio_ffmpeg available, emit ai_iter.mp4 at 12 fps.
    """
    try:
        viz_dir = out_dir / "viz"
        if not viz_dir.is_dir():
            return

        evidence_path = out_dir / "evidence_log.jsonl"
        metrics_path = out_dir / "metrics.json"

        offset_path = viz_dir / ".overlay_offset"
        samples, new_offset = _read_evidence_incremental(evidence_path, offset_path)
        if new_offset and new_offset != 0:
            try:
                offset_path.write_text(str(new_offset), encoding="utf-8")
            except Exception:
                pass

        # Even if no new samples from incremental read, we want last-known values
        # so we may parse whole file once if needed.
        if not samples and evidence_path.is_file():
            # Best-effort full scan in fallback mode
            try:
                with evidence_path.open("r", encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if not line:
                            continue
                        try:
                            rec = json.loads(line)
                        except Exception:
                            continue
                        if isinstance(rec, dict):
                            s = _parse_iter_event(rec)
                            if s is not None:
                                samples.append(s)
            except Exception:
                samples = []

        metrics = _load_metrics_info(metrics_path)

        frames = _list_frame_paths(viz_dir)
        if not frames:
            return

        if not _ensure_pil():
            logger.warning(
                "iter_viz: Pillow not available; skipping PNG overlays."
            )
            # We may still try to synthesize MP4 from existing PNGs later.
        else:
            # Build overlay text using last sample.
            last_iter = samples[-1].iter if samples else None
            last_resid = samples[-1].resid if samples else None
            last_tile_src = samples[-1].tile_src if samples else None
            last_tile_tgt = samples[-1].tile_tgt if samples else None
            last_t_ms = samples[-1].t_iter_ms if samples else None

            for frame in frames:
                try:
                    base = Image.open(frame)
                except Exception:
                    continue

                lines: List[str] = []

                if last_iter is not None:
                    lines.append(
                        f"Iter {int(last_iter)}  resid {_scientific(last_resid)}"
                    )

                if last_tile_src or last_tile_tgt:
                    if last_tile_src and last_tile_tgt:
                        lines.append(f"Tiles: {last_tile_src} x {last_tile_tgt}")
                    elif last_tile_src:
                        lines.append(f"Tile: {last_tile_src}")
                # t_iter_ms
                if last_t_ms is not None:
                    try:
                        lines.append(f"t_iter: {float(last_t_ms):.1f} ms")
                    except Exception:
                        pass

                if metrics.gpu_mem_peak_mb is not None:
                    lines.append(
                        f"GPU peak: {metrics.gpu_mem_peak_mb:.1f} MB"
                    )

                if not lines:
                    # Nothing to overlay; skip writing.
                    continue

                annotated = _draw_overlay_on_image(base, lines)

                # Save as *_overlay.png next to original.
                if frame.name == "viz.png":
                    out_name = "viz_overlay.png"
                else:
                    out_name = f"{frame.stem}_overlay.png"
                out_path = frame.with_name(out_name)
                _atomic_write_image(annotated, out_path)

        # Optionally package MP4.
        _maybe_write_video(viz_dir, logger)

        # Logging summary
        last_iter = samples[-1].iter if samples else None
        last_resid = samples[-1].resid if samples else None
        logger.info(
            "iter_viz overlay complete.",
            frames_scanned=len(frames),
            frames_with_overlays=len(
                [p for p in viz_dir.glob("*_overlay.png")]
            ),
            last_iter=last_iter,
            last_resid=_scientific(last_resid),
            video_exists=(viz_dir / "ai_iter.mp4").is_file(),
        )
    except Exception as exc:  # pragma: no cover - defensive
        try:
            logger.warning(
                "iter_viz overlay failed (non-fatal).",
                error=str(exc),
            )
        except Exception:
            pass


# -----------------------------------------------------------------------------
# Video writer (best-effort, optional imageio_ffmpeg)
# -----------------------------------------------------------------------------


def _detect_video_backend():
    """
    Return ("imageio", imageio_module) or None if MP4 writing is unavailable.
    """
    try:
        import imageio.v3 as iio  # type: ignore
    except Exception:
        try:
            import imageio as iio  # type: ignore
        except Exception:
            return None

    # Check ffmpeg availability in imageio if possible.
    try:
        import imageio_ffmpeg  # type: ignore  # noqa: F401

        # If import succeeds, assume OK.
        return "imageio", iio
    except Exception:
        # Some imageio builds ship bundled ffmpeg; try anyway.
        return "imageio", iio


def _maybe_write_video(viz_dir: Path, logger: JsonlLogger) -> None:
    """
    If possible, write ai_iter.mp4 at 12 fps from *_overlay.png or viz_*.png.
    Best-effort; never raises.
    """
    try:
        backend = _detect_video_backend()
        if backend is None:
            logger.warning(
                "iter_viz: imageio/imageio_ffmpeg unavailable; skipping MP4."
            )
            return
        _, iio = backend

        # Prefer overlay frames if present; else use base viz_*.png.
        frames = sorted(viz_dir.glob("viz_*_overlay.png"))
        if not frames:
            frames = sorted(viz_dir.glob("viz_*.png"))
        if not frames:
            # As a last resort, include viz.png / viz_overlay.png.
            if (viz_dir / "viz_overlay.png").is_file():
                frames = [viz_dir / "viz_overlay.png"]
            elif (viz_dir / "viz.png").is_file():
                frames = [viz_dir / "viz.png"]
        if not frames:
            return

        out_path = viz_dir / "ai_iter.mp4"

        # Avoid re-writing if it already exists and appears non-empty.
        try:
            if out_path.is_file() and out_path.stat().st_size > 0:
                return
        except Exception:
            pass

        # Use imageio to stream video (simple API; tolerant of both v2/v3)
        fps = 12
        try:
            # Newer imageio.v3
            writer = iio.get_writer(str(out_path), fps=fps, codec="libx264")
        except Exception:
            try:
                # Fallback API
                writer = iio.get_writer(str(out_path), fps=fps)
            except Exception as exc:
                logger.warning(
                    "iter_viz: failed to initialize MP4 writer.",
                    error=str(exc),
                )
                return

        try:
            for frame in frames:
                try:
                    img = None
                    if _HAVE_PIL:
                        img = Image.open(frame)
                        arr = None
                        try:
                            # Lazy import numpy inside loop
                            import numpy as np  # type: ignore

                            arr = np.array(img)
                        except Exception:
                            arr = None
                        if arr is not None:
                            writer.append_data(arr)
                        else:
                            # imageio can often handle PIL.Image directly
                            writer.append_data(img)
                    else:
                        writer.append_data(iio.imread(str(frame)))
                except Exception:
                    continue
        finally:
            try:
                writer.close()
            except Exception:
                pass

        logger.info(
            "iter_viz: MP4 video written.",
            path=str(out_path),
            fps=fps,
            frames=len(frames),
        )
    except Exception:
        # Never propagate
        pass


# -----------------------------------------------------------------------------
# IterVizRecorder
# -----------------------------------------------------------------------------


@dataclass
class IterVizRecorder:
    """
    Lightweight per-iteration visualization recorder.

    Usage:
        rec = IterVizRecorder(viz_dir, every=2, max_frames=2000)
        for k in range(max_iters):
            rec.update(iter=k, resid=..., tile_src=..., tile_tgt=..., t_iter=...)

    Behavior:
        - If Matplotlib (and its Agg backend) is unavailable, rec.update()
          becomes a no-op.
        - Respects:
            every: write a frame only when iter % every == 0
            max_frames: hard cap on frames; sets capped=True when reached
        - meta["marks"]: queue of one-shot labels; if non-empty, the next frame
          consumes meta["marks"][0] and stamps it in top-right.
    """

    viz_dir: Path
    every: int = 2
    max_frames: int = 2000

    frames_written: int = 0
    capped: bool = False

    meta: Dict[str, Any] = field(
        default_factory=lambda: {"marks": []}
    )

    _mpl_ready: bool = field(init=False, default=False)
    _initialized: bool = field(init=False, default=False)

    def __post_init__(self) -> None:
        try:
            self.viz_dir = Path(self.viz_dir)
            self.viz_dir.mkdir(parents=True, exist_ok=True)
        except Exception:
            # If we cannot create dir, mark as capped/no-op.
            self.capped = True

    # ----------------------------
    # Internal helpers
    # ----------------------------

    def _ensure_mpl(self) -> bool:
        """
        Lazy Matplotlib import. Returns True if we can render frames.
        """
        if self._initialized:
            return self._mpl_ready
        self._initialized = True
        try:
            import matplotlib

            # Use headless backend; safe to call multiple times.
            try:
                matplotlib.use("Agg")
            except Exception:
                pass
            import matplotlib.pyplot as plt  # noqa: F401

            self._mpl_ready = True
        except Exception:
            self._mpl_ready = False
        return self._mpl_ready

    # ----------------------------
    # Public API
    # ----------------------------

    def update(
        self,
        iter: int,
        resid: float,
        tile_src: Optional[int] = None,
        tile_tgt: Optional[int] = None,
        t_iter: Optional[float] = None,
    ) -> None:
        """
        Potentially emit a frame for this iteration.

        All parameters are trusted only for display; parsing/formatting is defensive.
        """
        if self.capped:
            return
        try:
            if self.every <= 0:
                # Normalize to safe value
                self.every = 1
            if iter % self.every != 0:
                return
        except Exception:
            # If iter is weird, skip
            return

        if self.frames_written >= self.max_frames:
            self.capped = True
            return

        if not self._ensure_mpl():
            # No Matplotlib => no-op
            self.capped = True
            return

        self._dump_frame(iter, resid, tile_src, tile_tgt, t_iter)

    def _dump_frame(
        self,
        iter: int,
        resid: float,
        tile_src: Optional[int],
        tile_tgt: Optional[int],
        t_iter: Optional[float],
    ) -> None:
        """
        Render a minimal synthetic frame and write iter_XXXX.png atomically.
        """
        try:
            import matplotlib.pyplot as plt
            import numpy as np  # type: ignore
        except Exception:
            self.capped = True
            return

        # Create a neutral gradient background so frames aren't empty
        fig, ax = None, None
        try:
            fig, ax = plt.subplots(figsize=(4, 3), dpi=100)
            x = np.linspace(0.0, 1.0, 64)
            y = np.linspace(0.0, 1.0, 64)
            X, Y = np.meshgrid(x, y)
            Z = X * 0.0 + Y  # simple vertical gradient
            ax.imshow(
                Z,
                origin="lower",
                cmap="Greys",
                extent=[0, 1, 0, 1],
                vmin=0,
                vmax=1,
            )
            ax.set_xticks([])
            ax.set_yticks([])
            ax.set_title("GMRES iteration", fontsize=9)

            # Text overlay inside the plot
            lines: List[str] = [
                f"iter {int(iter)}",
                f"resid {_scientific(_safe_float(resid))}",
            ]

            if tile_src or tile_tgt:
                if tile_src and tile_tgt:
                    lines.append(f"tiles {int(tile_src)} x {int(tile_tgt)}")
                elif tile_src:
                    lines.append(f"tile {int(tile_src)}")
            if t_iter is not None:
                try:
                    t_ms = float(t_iter) * 1e3
                    lines.append(f"{t_ms:.1f} ms/iter")
                except Exception:
                    pass

            text = "\n".join(lines)
            ax.text(
                0.02,
                0.98,
                text,
                transform=ax.transAxes,
                va="top",
                ha="left",
                fontsize=8,
                color="white",
                bbox=dict(
                    boxstyle="round,pad=0.2",
                    facecolor="black",
                    alpha=0.6,
                ),
            )

            # One-shot snapshot mark (meta["marks"] queue)
            try:
                marks = self.meta.get("marks") or []
                if isinstance(marks, list) and marks:
                    mark = str(marks.pop(0))
                else:
                    mark = None
            except Exception:
                mark = None

            if mark:
                ax.text(
                    0.98,
                    0.98,
                    mark,
                    transform=ax.transAxes,
                    va="top",
                    ha="right",
                    fontsize=8,
                    color="#ffcc66",
                    bbox=dict(
                        boxstyle="round,pad=0.2",
                        facecolor="black",
                        alpha=0.6,
                    ),
                )

            fig.tight_layout()

            # Save atomically
            fname = f"iter_{int(iter):04d}.png"
            path = self.viz_dir / fname

            # Use fig.canvas to write to bytes, then atomic write.
            try:
                from io import BytesIO

                buf = BytesIO()
                fig.savefig(buf, format="png")
                buf.seek(0)
                _atomic_write_bytes(path, buf.read())
            except Exception:
                # Fallback: direct save (non-atomic)
                try:
                    fig.savefig(path)
                except Exception:
                    pass

            self.frames_written += 1
            if self.frames_written >= self.max_frames:
                self.capped = True
        except Exception:
            # Never let failures propagate
            pass
        finally:
            try:
                if fig is not None:
                    plt.close(fig)
            except Exception:
                pass

    def close(self) -> None:
        """
        Public no-op; present for API symmetry. Safe to call multiple times.
        """
        # No persistent resources to release; Matplotlib figures are closed per-frame.
        return